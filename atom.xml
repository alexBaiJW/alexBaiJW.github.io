<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poplar</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://poplar.life/"/>
  <updated>2019-01-06T13:43:40.488Z</updated>
  <id>http://poplar.life/</id>
  
  <author>
    <name>alex Bai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python线程池模拟实现</title>
    <link href="http://poplar.life/archives/c07a9f32.html"/>
    <id>http://poplar.life/archives/c07a9f32.html</id>
    <published>2019-01-06T13:36:00.000Z</published>
    <updated>2019-01-06T13:43:40.488Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>Python线程池模拟实现，模拟线程复用减少系统资源的开销。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 参考（有改动）:http://www.open-open.com/home/space-5679-do-blog-id-3247.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, work_num=<span class="number">1000</span>,thread_num=<span class="number">2</span>)</span>:</span></span><br><span class="line">        self.work_queue = Queue.Queue()</span><br><span class="line">        self.threads = []</span><br><span class="line">        self.__init_work_queue(work_num)</span><br><span class="line">        self.__init_thread_pool(thread_num)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化线程</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_thread_pool</span><span class="params">(self,thread_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(thread_num):</span><br><span class="line">            self.threads.append(Work(self.work_queue))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化工作队列</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_work_queue</span><span class="params">(self, jobs_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(jobs_num):</span><br><span class="line">            self.add_job(do_job, i)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        添加一项工作入队</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_job</span><span class="params">(self, func, *args)</span>:</span></span><br><span class="line">        self.work_queue.put((func, list(args)))<span class="comment">#任务入队，Queue内部实现了同步机制</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        检查剩余队列任务</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_queue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.work_queue.qsize()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        等待所有线程运行完毕</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_allcomplete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.threads:</span><br><span class="line">            <span class="keyword">if</span> item.isAlive():item.join()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, work_queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.work_queue = work_queue</span><br><span class="line">        self.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#死循环，从而让创建的线程在一定条件下关闭退出</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                do, args = self.work_queue.get(block=<span class="keyword">False</span>)<span class="comment">#任务异步出队，Queue内部实现了同步机制</span></span><br><span class="line">                do(args)</span><br><span class="line">                self.work_queue.task_done()<span class="comment">#通知系统任务完成</span></span><br><span class="line">            <span class="keyword">except</span> Exception,e:</span><br><span class="line">                <span class="keyword">print</span> str(e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#具体要做的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_job</span><span class="params">(args)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)<span class="comment">#模拟处理时间</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">print</span> threading.current_thread(), list(args)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    start = time.time()</span><br><span class="line">    work_manager =  WorkManager(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">    work_manager.wait_allcomplete()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"cost all time: %s"</span> % (end-start)</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Python线程池模拟实现，模拟线程复用减少系统资源的开销。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://poplar.life/categories/Python/"/>
    
    
      <category term="线程池" scheme="http://poplar.life/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程示例</title>
    <link href="http://poplar.life/archives/4a17b156.html"/>
    <id>http://poplar.life/archives/4a17b156.html</id>
    <published>2019-01-06T02:38:00.000Z</published>
    <updated>2019-01-06T12:28:33.026Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>基于代码示例展示Python多线程<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="单线程示例"><a href="#单线程示例" class="headerlink" title="单线程示例"></a>单线程示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_responses</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.google.com'</span>,</span><br><span class="line">        <span class="string">'http://www.amazon.com'</span>,</span><br><span class="line">        <span class="string">'http://www.ebay.com'</span>,</span><br><span class="line">        <span class="string">'http://www.alibaba.com'</span>,</span><br><span class="line">        <span class="string">'http://www.reddit.com'</span></span><br><span class="line">    ]</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        <span class="keyword">print</span> url</span><br><span class="line">        resp = urllib2.urlopen(url)</span><br><span class="line">        <span class="keyword">print</span> resp.getcode()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Elapsed time: %s"</span> % (time.time()-start)</span><br><span class="line"> </span><br><span class="line">get_responses()</span><br></pre></td></tr></table></figure><p>程序输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://www.google.com 200 </span><br><span class="line">http://www.amazon.com 200 </span><br><span class="line">http://www.ebay.com 200 </span><br><span class="line">http://www.alibaba.com 200 </span><br><span class="line">http://www.reddit.com 200 </span><br><span class="line">Elapsed time: 3.0814409256</span><br></pre></td></tr></table></figure></p><p>解读：URL按顺序被依次串行请求，网络请求会花费较长的时间，所以CPU在等待网络请求返回时一直处于闲置状态。</p><h3 id="多线程示例"><a href="#多线程示例" class="headerlink" title="多线程示例"></a>多线程示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetUrlThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.url = url </span><br><span class="line">        super(GetUrlThread, self).__init__()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        resp = urllib2.urlopen(self.url)</span><br><span class="line">        <span class="keyword">print</span> self.url, resp.getcode()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_responses</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.google.com'</span>, </span><br><span class="line">        <span class="string">'http://www.amazon.com'</span>, </span><br><span class="line">        <span class="string">'http://www.ebay.com'</span>, </span><br><span class="line">        <span class="string">'http://www.alibaba.com'</span>, </span><br><span class="line">        <span class="string">'http://www.reddit.com'</span></span><br><span class="line">    ]</span><br><span class="line">    start = time.time()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        t = GetUrlThread(url)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Elapsed time: %s"</span> % (time.time()-start)</span><br><span class="line"> </span><br><span class="line">get_responses()</span><br></pre></td></tr></table></figure><p>程序输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://www.reddit.com 200 </span><br><span class="line">http://www.google.com 200 </span><br><span class="line">http://www.amazon.com 200 </span><br><span class="line">http://www.alibaba.com 200 </span><br><span class="line">http://www.ebay.com 200 </span><br><span class="line">Elapsed time: 0.689890861511</span><br></pre></td></tr></table></figure></p><p>解读：通过多线程来减少CPU的等待时间，即在等待一个线程网络请求返回时，CPU可以继续处理其它线程中的请求操作。注意，在该多线程环境下，我们无法保证各请求的执行顺序。通过时间统计，可以看到在该IO密集应用中，处理性能得到了有效提升。</p><h3 id="多线程之线程安全"><a href="#多线程之线程安全" class="headerlink" title="多线程之线程安全"></a>多线程之线程安全</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line">lock = Lock()</span><br><span class="line">some_var = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#read the global variable and then increment it</span></span><br><span class="line">        <span class="keyword">global</span> some_var</span><br><span class="line">        lock.acquire() <span class="comment"># lock acquire</span></span><br><span class="line">        read_value = some_var</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"some_var in %s is %d"</span> % (self.name, read_value)</span><br><span class="line">        some_var = read_value + <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"some_var in %s after increment is %d"</span> % (self.name, some_var)</span><br><span class="line">        lock.release() <span class="comment"># lock release</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_increment_thread</span><span class="params">()</span>:</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">        t = IncrementThread()</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"After 50 modifications, some_var should have become 50"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"After 50 modifications, some_var is %d"</span> % (some_var,)</span><br><span class="line"> </span><br><span class="line">use_increment_thread()</span><br></pre></td></tr></table></figure><p>解读：通过Lock来实现全局变量的同步访问，防止由于资源竞争而导致执行结果的不确定性。</p><h3 id="多线程之原子操作"><a href="#多线程之原子操作" class="headerlink" title="多线程之原子操作"></a>多线程之原子操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">lock = Lock()</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateListThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.entries = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.entries.append(i)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">print</span> self.entries</span><br><span class="line">        lock.release()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_create_list_thread</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = CreateListThread()</span><br><span class="line">        t.start()</span><br><span class="line"> </span><br><span class="line">use_create_list_thread()</span><br></pre></td></tr></table></figure><p>解读：若不使用lock，运行几次会发现并没有打印出正确的结果，因为当一个线程正在打印时，CPU切换到了另一个线程，所以产生了不正确的结果。我们需要确保print self.entries是个逻辑上的原子操作，以防打印时被其他线程打断。该示例证明了一个线程不可以修改其他线程内部的变量（非全局变量）。</p><h3 id="多线程之threadpool"><a href="#多线程之threadpool" class="headerlink" title="多线程之threadpool"></a>多线程之threadpool</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threadpool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">'http://www.google.com'</span>, </span><br><span class="line">    <span class="string">'http://www.amazon.com'</span>, </span><br><span class="line">    <span class="string">'http://www.ebay.com'</span>, </span><br><span class="line">    <span class="string">'http://www.alibaba.com'</span>, </span><br><span class="line">    <span class="string">'http://www.reddit.com'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myRequest</span><span class="params">(url)</span>:</span></span><br><span class="line">    resp = urllib2.urlopen(url)</span><br><span class="line">    <span class="keyword">print</span> url, resp.getcode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeCost</span><span class="params">(request, n)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Elapsed time: %s"</span> % (time.time()-start)</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">pool = threadpool.ThreadPool(<span class="number">5</span>) <span class="comment"># 最多可创建5线程</span></span><br><span class="line"><span class="comment">#makeRequests(some_callable, list_of_args, callback)</span></span><br><span class="line">reqs = threadpool.makeRequests(myRequest, urls, timeCost)</span><br><span class="line">[ pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> reqs ]</span><br><span class="line">pool.wait()</span><br></pre></td></tr></table></figure><p>makeRequests创建了要开启多线程的函数，以及函数相关参数和回调函数，其中回调函数可省略。注意，threadpool不是线程安全的。</p><p><img src="/images/pasted-0.png" alt="upload successful"></p><p>引用链接：<a href="https://my.oschina.net/leejun2005/blog/179265" target="_blank" rel="noopener">理解 Python 中的多线程</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;基于代码示例展示Python多线程&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://poplar.life/categories/Python/"/>
    
    
      <category term="Python  多线程" scheme="http://poplar.life/tags/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Third</title>
    <link href="http://poplar.life/archives/e5f30f60.html"/>
    <id>http://poplar.life/archives/e5f30f60.html</id>
    <published>2018-12-25T12:41:00.000Z</published>
    <updated>2019-01-06T02:45:40.332Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Third：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>original:<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/</a><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h5 id="NameNode-高可用整体架构概述"><a href="#NameNode-高可用整体架构概述" class="headerlink" title="NameNode 高可用整体架构概述"></a>NameNode 高可用整体架构概述</h5><pre><code>在 Hadoop 1.0 时代，Hadoop 的两大核心组件 HDFS NameNode 和 JobTracker 都存在着单点问题，这其中以 NameNode 的单点问题尤为严重。因为 NameNode 保存了整个 HDFS 的元数据信息，一旦 NameNode 挂掉，整个 HDFS 就无法访问，同时 Hadoop 生态系统中依赖于 HDFS 的各个组件，包括 MapReduce、Hive、Pig 以及 HBase 等也都无法正常工作，并且重新启动 NameNode 和进行数据恢复的过程也会比较耗时。这些问题在给 Hadoop 的使用者带来困扰的同时，也极大地限制了 Hadoop 的使用场景，使得 Hadoop 在很长的时间内仅能用作离线存储和离线计算，无法应用到对可用性和数据一致性要求很高的在线应用场景中。所幸的是，在 Hadoop2.0 中，HDFS NameNode 和 YARN ResourceManger(JobTracker 在 2.0 中已经被整合到 YARN ResourceManger 之中) 的单点问题都得到了解决，经过多个版本的迭代和发展，目前已经能用于生产环境。HDFS NameNode 和 YARN ResourceManger 的高可用 (High Availability，HA) 方案基本类似，两者也复用了部分代码，但是由于 HDFS NameNode 对于数据存储和数据一致性的要求比 YARN ResourceManger 高得多，所以 HDFS NameNode 的高可用实现更为复杂一些，本文从内部实现的角度对 HDFS NameNode 的高可用机制进行详细的分析。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Third：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;original:&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-name-node/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="玩转大数据" scheme="http://poplar.life/categories/%E7%8E%A9%E8%BD%AC%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="测试，论文" scheme="http://poplar.life/tags/%E6%B5%8B%E8%AF%95%EF%BC%8C%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
</feed>
