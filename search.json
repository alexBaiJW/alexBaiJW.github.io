[{"title":"Spark事件监听详解","url":"/archives/9efd5164.html","content":"<Excerpt in index | 首页摘要>\n本文试图解释一下Spark中事件监听的实现原理。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 概述\nSpark中很多组件间都是靠事件消息实现通信，RPC和事件消息机制的目的都是实现组件之间的通信，前者解决远程通信问题，而后者则是在本地较为高效的通信方式。Spark中大量采用事件监听这种方式，实现driver端组件间的通信。本文试图解释一下Spark中事件监听的实现原理。\n\n### 观察者模式\n观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。其中发生改变的对象称为主题，被通知对象称之为观察者，一个主题可以有多个观察者，而观察者之间保持相对独立，可以根据需要增加和删除观察者，使得系统更易于扩展。\n\n![upload successful](/images/pasted-2.png)\n\n### Spark中的事件监听\n#### SparkListener\nSpark中的事件监听机制，其本质上就是观察者模式的实现。下面就以SparkListener为例来解析事件监听是如何设计的。首先我们看SparkListener\n\n```scala\nabstract class SparkListener extends SparkListenerInterface {\n  override def onExecutorAdded(executorAdded:SparkListenerExecutorAdded):Unit = { }\n  override def onExecutorRemoved(executorRemoved:SparkListenerExecutorRemoved): Unit = { }\n  \n  //略...\n}\n```\n\n为了简化分析，我们以executor的增删事件监听来做具体的分析。这里我们可以看到onExecutorAdded和onExecutorRemoved两个方法，很明显这是用来处理executor增删事件的方法。SparkListener继承自SparkListenerInterface接口，其内部就是这些方法的声明，代码省略。\n\n#### 监听器的结构\n很明显，要使得类的对象能够实现对executor事件的响应，就必须继承SparkListener。举例来讲，我们可以看到SaveExecutorInfo（org.apache.spark.deploy.SaveExecutorInfo）继承自SparkListener。\n```scala\nprivate[spark] class SaveExecutorInfo extends SparkListener {\n  val addedExecutorInfos = mutable.Map[String, ExecutorInfo]()\n  override def onExecutorAdded(executor: SparkListenerExecutorAdded) {\n    addedExecutorInfos(executor.executorId) = executor.executorInfo\n  }\n}\n```\n其重载了onExecutorAdded方法，收集executor的信息。\n\n#### 监听器如何使用\nSaveExecutorInfo是如何能够简单地通过继承自一个SparkListener类，甚至没有任何消息接受和处理逻辑，来实现事件响应呢？还是举例说明，我们可以看一下如何使用SaveExecutorInfo对象的。\n```scala\nclass LogUrlsStandaloneSuite extends SparkFunSuite with LocalSparkContext {\n    //部分代码省略\n    val listener = new SaveExecutorInfo\n    sc.addSparkListener(listener) //将一个SaveExecutorInfo监听器对象添加到sc中\n    // Trigger a job so that executors get added\n    sc.parallelize(1 to 100, 4).map(_.toString).count()\n    sc.listenerBus.waitUntilEmpty(WAIT_TIMEOUT_MILLIS)\n    listener.addedExecutorInfos.values.foreach { info =>\n      assert(info.logUrlMap.nonEmpty)\n      // Browse to each URL to check that it's valid\n      info.logUrlMap.foreach { case (logType, logUrl) =>\n        val html = Source.fromURL(logUrl).mkString\n        assert(html.contains(s\"$logType log page\"))\n      }\n    }\n    //部分代码省略\n}\n```\n#### 监听器如何工作\n这里可以看到，在声明了一个SaveExecutorInfo对象之后，需要将它添加到sc中，sc其实就是SparkContext对象，也就是一个Spark application唯一的入口。SparkContext中addSparkListener方法的代码如下：\n```scala\n/**\n * :: DeveloperApi ::\n * Register a listener to receive up-calls from events that happen during execution.\n */\n@DeveloperApi\ndef addSparkListener(listener: SparkListenerInterface) {\n  listenerBus.addListener(listener)\n}\n```\n这里的listenerBus，是一个监听器总线对象，其声明如下：\n\n```scala\nprivate[spark] val listenerBus = new LiveListenerBus\n```\n现在思路就变得很清晰了，SaveExecutorInfo对象是注册到LiveListenerBus对象中，然后通过LiveListenerBus对象来实现事件监听，其实这里我们通过取名就可以知道其设计思路，类似于计算机中的总线，设备都通过总线来传递消息，而LiveListenerBus就刚好充当了总线的角色，一个个SparkListener子类对象就是一个个的设备，它们可以接受来自总线的消息并作出相应的处理。\n\n#### 监听器总线如何传递消息\n我们可以看一下LiveListenerBus类，该类实现了SparkListenerBus接口，直接看其入口start方法：\n\n```scala\ndef start(sc: SparkContext): Unit = {\n  if (started.compareAndSet(false, true)) {\n    sparkContext = sc\n    listenerThread.start()\n  } else {\n    throw new IllegalStateException(s\"$name already started!\")\n  }\n}\n```\n直接启动了一个listenerThread：\n\n```scala\nprivate val listenerThread = new Thread(name) {\n  setDaemon(true)\n  override def run(): Unit = Utils.tryOrStopSparkContext(sparkContext) {\n    LiveListenerBus.withinListenerThread.withValue(true) {\n      while (true) {\n        eventLock.acquire()\n        self.synchronized {\n          processingEvent = true\n        }\n        try {\n          val event = eventQueue.poll\n          if (event == null) {\n            // Get out of the while loop and shutdown the daemon thread\n            if (!stopped.get) {\n              throw new IllegalStateException(\"Polling `null` from eventQueue means\" +\n                \" the listener bus has been stopped. So `stopped` must be true\")\n            }\n            return\n          }\n          postToAll(event)//将事件通知到所有注册的listener中\n        } finally {\n          self.synchronized {\n            processingEvent = false\n          }\n        }\n      }\n    }\n  }\n}\n\n```\n可以看到这个listenerThread是一个守护线程，其核心逻辑就是不停地在一个事件队列eventQueue里取出事件，如果事件合法且LiverListenerBus没有被关停，就将事件通知给所有注册的listener中，postToAll方法在ListenerBus接口中实现：\n\n```scala\nfinal def postToAll(event: E): Unit = {\n  // JavaConverters can create a JIterableWrapper if we use asScala.\n  // However, this method will be called frequently. To avoid the wrapper cost, here we use\n  // Java Iterator directly.\n  val iter = listeners.iterator\n  while (iter.hasNext) {\n    val listener = iter.next()\n    try {\n      doPostEvent(listener, event)\n    } catch {\n      case NonFatal(e) =>\n        logError(s\"Listener ${Utils.getFormattedClassName(listener)} threw an exception\", e)\n    }\n  }\n}\n```\n思路很清晰，就是用迭代器遍历listener，逐个将消息发送。而doPostEvent方法是一个抽象方法，其具体实现要由继承自ListerBus的类负责，比如之前举例中的SparkListener，就有相应的SparkListenerBus接口：\n\n```scala\nprivate[spark] trait SparkListenerBus\n  extends ListenerBus[SparkListenerInterface, SparkListenerEvent] {\n  protected override def doPostEvent(\n      listener: SparkListenerInterface,\n      event: SparkListenerEvent): Unit = {\n    event match {\n    \t//部分代码省略\n      case executorAdded: SparkListenerExecutorAdded =>\n        listener.onExecutorAdded(executorAdded)\n      case executorRemoved: SparkListenerExecutorRemoved =>\n        listener.onExecutorRemoved(executorRemoved)\n        //部分代码省略\n      case _ => listener.onOtherEvent(event)\n    }\n  }\n```\n这里对每个事件进行类型匹配，比如doPostEvent需要将executorAdded事件告知一个listener，对应地，这个listener就调用一下自己的onExecutorAdded方法，对该事件作出自己的反应，比如前面的SaveExecutorInfo就实现了onExecutorAdded方法，其内容就是保存一下executor的信息。到这里其实还有一个重要的问题被忽视，LiveListenerBus发给注册在它这里的listener的事件消息是从何而来的？细心一点就可以发现，LiveListenerBus中有一个post方法:\n\n```scala\ndef post(event: SparkListenerEvent): Unit = {\n  if (stopped.get) {\n    // Drop further events to make `listenerThread` exit ASAP\n    logError(s\"$name has already stopped! Dropping event $event\")\n    return\n  }\n  val eventAdded = eventQueue.offer(event)\n  if (eventAdded) {\n    eventLock.release()\n  } else {\n    onDropEvent(event)\n  }\n}\n```\n其核心就是向事件队列里添加相应的事件。\n\n### 小结\n总结之，Spark中监听器的实现核心其实就是一个个需要对事件响应的监听器对象，注册到一个监听器总线，需要发送事件消息的组件将发生的事件消息提交到总线，然后总线将事件消息转发给一个个注册在它上面的监听器，最后监听器对事件进行响应。其实就是一个典型的观察者模式使用。\n\n原文链接(有改动)：[Spark事件监听详解](https://wongxingjun.github.io/2017/01/01/Spark%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%AF%A6%E8%A7%A3/)","tags":["事件监听"],"categories":["Spark"]},{"title":"Python线程池模拟实现","url":"/archives/c07a9f32.html","content":"<Excerpt in index | 首页摘要>\nPython线程池模拟实现，模拟线程复用减少系统资源的开销。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n``` python\n# !/usr/bin/env python\n# -*- coding:utf-8 -*-\n# 参考（有改动）:http://www.open-open.com/home/space-5679-do-blog-id-3247.html\n\nimport Queue\nimport threading\nimport time\nfrom threading import Lock\n\n\nclass WorkManager(object):\n    def __init__(self, work_num=1000,thread_num=2):\n        self.work_queue = Queue.Queue()\n        self.threads = []\n        self.__init_work_queue(work_num)\n        self.__init_thread_pool(thread_num)\n\n    \"\"\"\n        初始化线程\n    \"\"\"\n    def __init_thread_pool(self,thread_num):\n        for i in range(thread_num):\n            self.threads.append(Work(self.work_queue))\n\n    \"\"\"\n        初始化工作队列\n    \"\"\"\n    def __init_work_queue(self, jobs_num):\n        for i in range(jobs_num):\n            self.add_job(do_job, i)\n\n    \"\"\"\n        添加一项工作入队\n    \"\"\"\n    def add_job(self, func, *args):\n        self.work_queue.put((func, list(args)))#任务入队，Queue内部实现了同步机制\n    \"\"\"\n        检查剩余队列任务\n    \"\"\"\n    def check_queue(self):\n        return self.work_queue.qsize()\n\n    \"\"\"\n        等待所有线程运行完毕\n    \"\"\"\n    def wait_allcomplete(self):\n        for item in self.threads:\n            if item.isAlive():item.join()\n\nclass Work(threading.Thread):\n    def __init__(self, work_queue):\n        threading.Thread.__init__(self)\n        self.work_queue = work_queue\n        self.start()\n\n    def run(self):\n        #死循环，从而让创建的线程在一定条件下关闭退出\n        while True:\n            try:\n                do, args = self.work_queue.get(block=False)#任务异步出队，Queue内部实现了同步机制\n                do(args)\n                self.work_queue.task_done()#通知系统任务完成\n            except Exception,e:\n                print str(e)\n                break\n\n#具体要做的任务\ndef do_job(args):\n    time.sleep(0.1)#模拟处理时间\n    lock.acquire()\n    print threading.current_thread(), list(args)\n    lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n    start = time.time()\n    work_manager =  WorkManager(10, 2)\n    work_manager.wait_allcomplete()\n    end = time.time()\n    print \"cost all time: %s\" % (end-start)\n    \n```\n\npython 的GIL规定每个时刻只能有一个线程访问python虚拟机，所以使用python多线程来做计算是很不合算的，但是对于IO密集型应用，python多线程效果还是很好的。\n\n那么对于计算密集型任务，如何实现并行执行呢？有以下几个方法：\n- python multiprocessing模块，发挥多核优势\n- pypy，可实现真正的多线程","tags":["线程池"],"categories":["Python"]},{"title":"Python多线程示例","url":"/archives/4a17b156.html","content":"<Excerpt in index | 首页摘要>\n基于代码示例展示Python多线程\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 单线程示例\n\n``` python\nimport time\nimport urllib2\n \ndef get_responses():\n    urls = [\n        'http://www.google.com',\n        'http://www.amazon.com',\n        'http://www.ebay.com',\n        'http://www.alibaba.com',\n        'http://www.reddit.com'\n    ]\n    start = time.time()\n    for url in urls:\n        print url\n        resp = urllib2.urlopen(url)\n        print resp.getcode()\n    print \"Elapsed time: %s\" % (time.time()-start)\n \nget_responses()\n```\n\n程序输出： \n```\nhttp://www.google.com 200 \nhttp://www.amazon.com 200 \nhttp://www.ebay.com 200 \nhttp://www.alibaba.com 200 \nhttp://www.reddit.com 200 \nElapsed time: 3.0814409256\n```\n\n解读：URL按顺序被依次串行请求，网络请求会花费较长的时间，所以CPU在等待网络请求返回时一直处于闲置状态。\n\n\n\n### 多线程示例\n\n``` python\nimport urllib2\nimport time\nfrom threading import Thread\n \nclass GetUrlThread(Thread):\n    def __init__(self, url):\n        self.url = url \n        super(GetUrlThread, self).__init__()\n \n    def run(self):\n        resp = urllib2.urlopen(self.url)\n        print self.url, resp.getcode()\n \ndef get_responses():\n    urls = [\n        'http://www.google.com', \n        'http://www.amazon.com', \n        'http://www.ebay.com', \n        'http://www.alibaba.com', \n        'http://www.reddit.com'\n    ]\n    start = time.time()\n    threads = []\n    for url in urls:\n        t = GetUrlThread(url)\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()\n    print \"Elapsed time: %s\" % (time.time()-start)\n \nget_responses()\n\n```\n\n程序输出：\n```\nhttp://www.reddit.com 200 \nhttp://www.google.com 200 \nhttp://www.amazon.com 200 \nhttp://www.alibaba.com 200 \nhttp://www.ebay.com 200 \nElapsed time: 0.689890861511\n```\n\n解读：通过多线程来减少CPU的等待时间，即在等待一个线程网络请求返回时，CPU可以继续处理其它线程中的请求操作。注意，在该多线程环境下，我们无法保证各请求的执行顺序。通过时间统计，可以看到在该IO密集应用中，处理性能得到了有效提升。\n\n### 多线程之线程安全\n\n``` python\nfrom threading import Lock, Thread\nlock = Lock()\nsome_var = 0\n \nclass IncrementThread(Thread):\n    def run(self):\n        #read the global variable and then increment it\n        global some_var\n        lock.acquire() # lock acquire\n        read_value = some_var\n        print \"some_var in %s is %d\" % (self.name, read_value)\n        some_var = read_value + 1\n        print \"some_var in %s after increment is %d\" % (self.name, some_var)\n        lock.release() # lock release\n \ndef use_increment_thread():\n    threads = []\n    for i in range(50):\n        t = IncrementThread()\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()\n    print \"After 50 modifications, some_var should have become 50\"\n    print \"After 50 modifications, some_var is %d\" % (some_var,)\n \nuse_increment_thread()\n```\n解读：通过Lock来实现全局变量的同步访问，防止由于资源竞争而导致执行结果的不确定性。\n\n### 多线程之原子操作\n\n``` python\nfrom threading import Thread, Lock\nimport time\n \nlock = Lock()\n \nclass CreateListThread(Thread):\n    def run(self):\n        self.entries = []\n        for i in range(10):\n            time.sleep(0.01)\n            self.entries.append(i)\n        lock.acquire()\n        print self.entries\n        lock.release()\n \ndef use_create_list_thread():\n    for i in range(3):\n        t = CreateListThread()\n        t.start()\n \nuse_create_list_thread()\n```\n解读：若不使用lock，运行几次会发现并没有打印出正确的结果，因为当一个线程正在打印时，CPU切换到了另一个线程，所以产生了不正确的结果。我们需要确保print self.entries是个逻辑上的原子操作，以防打印时被其他线程打断。该示例证明了一个线程不可以修改其他线程内部的变量（非全局变量）。\n\n### 多线程之threadpool\n\n``` python\nimport threadpool\nimport time\nimport urllib2\n\nurls = [\n    'http://www.google.com', \n    'http://www.amazon.com', \n    'http://www.ebay.com', \n    'http://www.alibaba.com', \n    'http://www.reddit.com'\n]\n\ndef myRequest(url):\n    resp = urllib2.urlopen(url)\n    print url, resp.getcode()\n\n\ndef timeCost(request, n):\n  print \"Elapsed time: %s\" % (time.time()-start)\n\nstart = time.time()\npool = threadpool.ThreadPool(5) # 最多可创建5线程\n#makeRequests(some_callable, list_of_args, callback)\nreqs = threadpool.makeRequests(myRequest, urls, timeCost)\n[ pool.putRequest(req) for req in reqs ]\npool.wait()\n\n```\nmakeRequests创建了要开启多线程的函数，以及函数相关参数和回调函数，其中回调函数可省略。注意，threadpool不是线程安全的。\n\n![upload successful](/images/pasted-0.png)\n\n引用链接：[理解 Python 中的多线程](https://my.oschina.net/leejun2005/blog/179265)","tags":["多线程"],"categories":["Python"]},{"title":"JAX-RS 简化 REST 应用开发","url":"/archives/e5f30f60.html","content":"<Excerpt in index | 首页摘要>\nJAX-RS 简化 REST 应用开发<!-- more -->\n<The rest of contents | 余下全文>\n### REST 简介\n\nREST即Representational State Transfer，由 Roy Fielding 在其博士论文 《 Architectural Styles and the Design of Network-based Software Architectures 》中提出，所以REST 并非标准，而是一种开发 Web 应用的架构风格。REST 基于 HTTP，URI（Uniform Resource Identifier）以及 XML 等现有的、广泛流行的协议和标准，促进了HTTP协议更好的使用。\n\n相较于基于 SOAP 和 WSDL 的 Web 服务，REST 模式提供了更为简洁的实现方案。目前，越来越多的 Web 服务采用了 REST 风格设计和实现，真实世界中比较著名的 REST 服务包括：Google AJAX 搜索 API、Amazon Simple Storage Service (Amazon S3)等。\n\n基于 REST 的 Web 服务遵循一些基本的设计原则：\n\n- 系统中每一个对象或资源都可以通过一个唯一的 URI 进行寻址，URI 的结构应该简单、可预测且易于理解\n- 以遵循 RFC-2616 定义的协议方式显式地使用 HTTP 方法，CRUD（Create, Retrieve, Update and Delete）操作与 HTTP 方法之间一一映射：\n\t- 若要在服务器上创建资源，应使用 POST 方法；\n\t- 若要检索某个资源，应该使用 GET 方法；\n\t- 若要更改资源状态或对其进行更新，应该使用 PUT 方法；\n\t- 若要删除某个资源，应该使用 DELETE 方法。\n- URI访问的每个资源都可以使用不同的形式进行表示（比如 XML、JSON），具体的表现形式取决于访问资源的客户端，客户端与服务提供者使用一种内容协商机制（请求头与 MIME 类型）来选择合适的数据格式，最小化彼此之间的数据耦合。\n\n### JAX-RS -- Java API for RESTful Web Services\n\nJava EE 6 引入了对 JSR-311 的支持。JSR-311（JAX-RS：Java API for RESTful Web Services）旨在定义一个统一规范，使得 Java 程序员可以使用一套固定的接口来开发 REST 应用，避免依赖于第三方框架。同时，JAX-RS 使用 POJO 编程模型和基于标注的配置，并集成了 JAXB，从而可以有效缩短 REST 应用的开发周期。\n\nJAX-RS 定义的 API 位于 javax.ws.rs 包中，其中一些主要的接口、标注和抽象类如图所示：\n![upload successful](/images/pasted-1.png)\nJAX-RS具体实现由第三方提供，例如 Sun Jersey、Apache CXF 以及 JBoss RESTEasy。\n\nWeb 资源作为一个 Resource 类来实现，对资源的请求由 Resource 方法来处理。Resource 类或 Resource 方法被打上了 Path 标注，Path 标注的值是一个相对的 URI 路径，用于对资源进行定位，路径中可以包含任意的正则表达式以匹配资源。和大多数 JAX-RS 标注一样，Path 标注是可继承的，子类或实现类可以继承超类或接口中的 Path 标注。\n\n\n#### 参数标注\n\nJAX-RS 中涉及 Resource 方法参数的标注包括：@PathParam、@MatrixParam、@QueryParam、@FormParam、@HeaderParam、@CookieParam、@DefaultValue 和 @Encoded。这其中最常用的是 @PathParam，它用于将 @Path 中的模板变量映射到方法参数，模板变量支持使用正则表达式，变量名与正则表达式之间用分号分隔，例如：@Path(\"/person/{id:\\\\d+}/\") 。\n\nJAX-RS 规定 Resource 方法中只允许有一个参数没有打上任何的参数标注，该参数称为实体参数，用于映射请求体。\n\n#### 参数与返回值类型\nResource 方法合法的参数类型包括：\n\n1. 原生类型\n2. 构造函数接收单个字符串参数或者包含接收单个字符串参数的静态方法 valueOf的任意类型\n3. List<T>，Set<T>，SortedSet<T>（T 为以上的 2 种类型）\n4. 用于映射请求体的实体参数\n\nResource 方法合法的返回值类型包括：\n\n1. void：状态码 204 和空响应体\n2. Response：Response 的 status 属性指定了状态码，entity 属性映射为响应体\n3. GenericEntity：GenericEntity 的 entity 属性映射为响应体，entity 属性为空则状态码为 204，非空则状态码为 200\n4. 其它类型：返回的对象实例映射为响应体，实例为空则状态码为 204，非空则状态码为 200\n\n对于错误处理，Resource 方法可以抛出非受控异常 WebApplicationException 或者返回包含了适当的错误码集合的 Response 对象。\n\n#### Context 标注\n通过 Context 标注，根 Resource 类的实例字段可以被注入如下类型的上下文资源：\n\n- Request、UriInfo、HttpHeaders、Providers、SecurityContext\n- HttpServletRequest、HttpServletResponse、ServletContext、ServletConfig\n\n### 内容协商与数据绑定\n\nWeb 资源可以有不同的表现形式，服务端与客户端之间需要一种称为内容协商（Content Negotiation）的机制：作为服务端，Resource 方法的 Produces 标注用于指定响应体的数据格式（MIME 类型），Consumes 标注用于指定请求体的数据格式；作为客户端，Accept 请求头用于选择响应体的数据格式，Content-Type 请求头用于标识请求体的数据格式。\n\nJAX-RS 依赖于 MessageBodyReader 和 MessageBodyWriter 的实现来自动完成返回值到响应体的序列化以及请求体到实体参数的反序列化工作，其中，XML 格式的请求／响应数据与 Java 对象的自动绑定依赖于 JAXB 的实现。\n\n用户可以使用 Provider 标注来注册使用自定义的 MessageBodyProvider。如例子所示，GsonProvider 类使用了 Google Gson 作为 JSON 格式的 MessageBodyProvider 的实现。\n\n``` java\n@Provider \n@Produces(\"application/json\") \n@Consumes(\"application/json\") \npublic class GsonProvider implements MessageBodyWriter<Object>, MessageBodyReader<Object> { \n \n   private final Gson gson; \n \n   public GsonProvider() { \n       gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setDateFormat( \n               \"yyyy-MM-dd\").create(); \n   } \n \n   public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return true; \n   } \n \n   public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType,  MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException { \n       return gson.fromJson(new InputStreamReader(entityStream, \"UTF-8\"), type); \n   } \n \n   public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return true; \n   } \n \n   public long getSize(Object obj, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return -1; \n   } \n \n   public void writeTo(Object obj, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)throws IOException, WebApplicationException { \n       entityStream.write(gson.toJson(obj, type).getBytes(\"UTF-8\")); \n   } \n}\n```\n### JAX-RS 与 JPA 的结合使用\n由于 JAX-RS 和 JPA 同样都使用了基于 POJO 和标注的编程模型，因而很易于结合在一起使用。示例应用中的 Web 资源同时也是持久化到数据库中的实体，同一个 POJO 类上既有 JAXB 的标注，也有 JPA 的标注 ( 或者还有 Gson 的标注 ) ，这使得应用中类的个数得以减少。如例子所示，Account 类可以在 JAX-RS 与 JPA 之间得到复用，它不但可以被 JAX-RS 绑定为请求体 / 响应体的 XML/JSON 数据，也可以被 JPA 持久化到关系型数据库中。\n\n``` java\n@Entity \n@Table(name = \"TABLE_ACCOUNT\") \n@XmlRootElement \npublic class Account { \n   @Id \n   @GeneratedValue(strategy = GenerationType.IDENTITY) \n   @Column(name = \"COL_ID\") \n   @Expose \n   private int id; \n \n   @ManyToOne \n   @JoinColumn(name = \"COL_PERSON\") \n   @Expose \n   private Person person; \n \n   @Column(name = \"COL_AMOUNT\") \n   @Expose \n   private BigDecimal amount; \n \n   @Column(name = \"COL_DATE\") \n   @Expose \n   private Date date; \n \n   @ManyToOne \n   @JoinColumn(name = \"COL_CATEGORY\") \n   @Expose \n   private Category category; \n \n   @Column(name = \"COL_COMMENT\") \n   @Expose \n   private String comment; \n   \n   ......\n```\n\n### 总结\nREST 作为一种轻量级的 Web 服务架构被越来越多的开发者所采用，JAX-RS 的发布则规范了 REST 应用开发的接口。\n\n引用链接：[使用 JAX-RS 简化 REST 应用开发](https://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/)","tags":["JAX-RS"],"categories":["REST"]}]