[{"title":"Python线程池模拟实现","url":"/archives/c07a9f32.html","content":"<Excerpt in index | 首页摘要>\nPython线程池模拟实现，模拟线程复用减少系统资源的开销。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n``` python\n# !/usr/bin/env python\n# -*- coding:utf-8 -*-\n# 参考（有改动）:http://www.open-open.com/home/space-5679-do-blog-id-3247.html\n\nimport Queue\nimport threading\nimport time\nfrom threading import Lock\n\n\nclass WorkManager(object):\n    def __init__(self, work_num=1000,thread_num=2):\n        self.work_queue = Queue.Queue()\n        self.threads = []\n        self.__init_work_queue(work_num)\n        self.__init_thread_pool(thread_num)\n\n    \"\"\"\n        初始化线程\n    \"\"\"\n    def __init_thread_pool(self,thread_num):\n        for i in range(thread_num):\n            self.threads.append(Work(self.work_queue))\n\n    \"\"\"\n        初始化工作队列\n    \"\"\"\n    def __init_work_queue(self, jobs_num):\n        for i in range(jobs_num):\n            self.add_job(do_job, i)\n\n    \"\"\"\n        添加一项工作入队\n    \"\"\"\n    def add_job(self, func, *args):\n        self.work_queue.put((func, list(args)))#任务入队，Queue内部实现了同步机制\n    \"\"\"\n        检查剩余队列任务\n    \"\"\"\n    def check_queue(self):\n        return self.work_queue.qsize()\n\n    \"\"\"\n        等待所有线程运行完毕\n    \"\"\"\n    def wait_allcomplete(self):\n        for item in self.threads:\n            if item.isAlive():item.join()\n\nclass Work(threading.Thread):\n    def __init__(self, work_queue):\n        threading.Thread.__init__(self)\n        self.work_queue = work_queue\n        self.start()\n\n    def run(self):\n        #死循环，从而让创建的线程在一定条件下关闭退出\n        while True:\n            try:\n                do, args = self.work_queue.get(block=False)#任务异步出队，Queue内部实现了同步机制\n                do(args)\n                self.work_queue.task_done()#通知系统任务完成\n            except Exception,e:\n                print str(e)\n                break\n\n#具体要做的任务\ndef do_job(args):\n    time.sleep(0.1)#模拟处理时间\n    lock.acquire()\n    print threading.current_thread(), list(args)\n    lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n    start = time.time()\n    work_manager =  WorkManager(10, 2)\n    work_manager.wait_allcomplete()\n    end = time.time()\n    print \"cost all time: %s\" % (end-start)\n    \n```\n\npython 的GIL规定每个时刻只能有一个线程访问python虚拟机，所以使用python多线程来做计算是很不合算的，但是对于IO密集型应用，python多线程效果还是很好的。\n\n那么对于计算密集型任务，如何实现并行执行呢？有以下几个方法：\n- python multiprocessing模块，发挥多核优势\n- pypy，可实现真正的多线程","tags":["线程池"],"categories":["Python"]},{"title":"Python多线程示例","url":"/archives/4a17b156.html","content":"<Excerpt in index | 首页摘要>\n基于代码示例展示Python多线程\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 单线程示例\n\n``` python\nimport time\nimport urllib2\n \ndef get_responses():\n    urls = [\n        'http://www.google.com',\n        'http://www.amazon.com',\n        'http://www.ebay.com',\n        'http://www.alibaba.com',\n        'http://www.reddit.com'\n    ]\n    start = time.time()\n    for url in urls:\n        print url\n        resp = urllib2.urlopen(url)\n        print resp.getcode()\n    print \"Elapsed time: %s\" % (time.time()-start)\n \nget_responses()\n```\n\n程序输出： \n```\nhttp://www.google.com 200 \nhttp://www.amazon.com 200 \nhttp://www.ebay.com 200 \nhttp://www.alibaba.com 200 \nhttp://www.reddit.com 200 \nElapsed time: 3.0814409256\n```\n\n解读：URL按顺序被依次串行请求，网络请求会花费较长的时间，所以CPU在等待网络请求返回时一直处于闲置状态。\n\n\n\n### 多线程示例\n\n``` python\nimport urllib2\nimport time\nfrom threading import Thread\n \nclass GetUrlThread(Thread):\n    def __init__(self, url):\n        self.url = url \n        super(GetUrlThread, self).__init__()\n \n    def run(self):\n        resp = urllib2.urlopen(self.url)\n        print self.url, resp.getcode()\n \ndef get_responses():\n    urls = [\n        'http://www.google.com', \n        'http://www.amazon.com', \n        'http://www.ebay.com', \n        'http://www.alibaba.com', \n        'http://www.reddit.com'\n    ]\n    start = time.time()\n    threads = []\n    for url in urls:\n        t = GetUrlThread(url)\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()\n    print \"Elapsed time: %s\" % (time.time()-start)\n \nget_responses()\n\n```\n\n程序输出：\n```\nhttp://www.reddit.com 200 \nhttp://www.google.com 200 \nhttp://www.amazon.com 200 \nhttp://www.alibaba.com 200 \nhttp://www.ebay.com 200 \nElapsed time: 0.689890861511\n```\n\n解读：通过多线程来减少CPU的等待时间，即在等待一个线程网络请求返回时，CPU可以继续处理其它线程中的请求操作。注意，在该多线程环境下，我们无法保证各请求的执行顺序。通过时间统计，可以看到在该IO密集应用中，处理性能得到了有效提升。\n\n### 多线程之线程安全\n\n``` python\nfrom threading import Lock, Thread\nlock = Lock()\nsome_var = 0\n \nclass IncrementThread(Thread):\n    def run(self):\n        #read the global variable and then increment it\n        global some_var\n        lock.acquire() # lock acquire\n        read_value = some_var\n        print \"some_var in %s is %d\" % (self.name, read_value)\n        some_var = read_value + 1\n        print \"some_var in %s after increment is %d\" % (self.name, some_var)\n        lock.release() # lock release\n \ndef use_increment_thread():\n    threads = []\n    for i in range(50):\n        t = IncrementThread()\n        threads.append(t)\n        t.start()\n    for t in threads:\n        t.join()\n    print \"After 50 modifications, some_var should have become 50\"\n    print \"After 50 modifications, some_var is %d\" % (some_var,)\n \nuse_increment_thread()\n```\n解读：通过Lock来实现全局变量的同步访问，防止由于资源竞争而导致执行结果的不确定性。\n\n### 多线程之原子操作\n\n``` python\nfrom threading import Thread, Lock\nimport time\n \nlock = Lock()\n \nclass CreateListThread(Thread):\n    def run(self):\n        self.entries = []\n        for i in range(10):\n            time.sleep(0.01)\n            self.entries.append(i)\n        lock.acquire()\n        print self.entries\n        lock.release()\n \ndef use_create_list_thread():\n    for i in range(3):\n        t = CreateListThread()\n        t.start()\n \nuse_create_list_thread()\n```\n解读：若不使用lock，运行几次会发现并没有打印出正确的结果，因为当一个线程正在打印时，CPU切换到了另一个线程，所以产生了不正确的结果。我们需要确保print self.entries是个逻辑上的原子操作，以防打印时被其他线程打断。该示例证明了一个线程不可以修改其他线程内部的变量（非全局变量）。\n\n### 多线程之threadpool\n\n``` python\nimport threadpool\nimport time\nimport urllib2\n\nurls = [\n    'http://www.google.com', \n    'http://www.amazon.com', \n    'http://www.ebay.com', \n    'http://www.alibaba.com', \n    'http://www.reddit.com'\n]\n\ndef myRequest(url):\n    resp = urllib2.urlopen(url)\n    print url, resp.getcode()\n\n\ndef timeCost(request, n):\n  print \"Elapsed time: %s\" % (time.time()-start)\n\nstart = time.time()\npool = threadpool.ThreadPool(5) # 最多可创建5线程\n#makeRequests(some_callable, list_of_args, callback)\nreqs = threadpool.makeRequests(myRequest, urls, timeCost)\n[ pool.putRequest(req) for req in reqs ]\npool.wait()\n\n```\nmakeRequests创建了要开启多线程的函数，以及函数相关参数和回调函数，其中回调函数可省略。注意，threadpool不是线程安全的。\n\n![upload successful](/images/pasted-0.png)\n\n引用链接：[理解 Python 中的多线程](https://my.oschina.net/leejun2005/blog/179265)","tags":["多线程"],"categories":["Python"]},{"title":"JAX-RS 简化 REST 应用开发","url":"/archives/e5f30f60.html","content":"<Excerpt in index | 首页摘要>\nJAX-RS 简化 REST 应用开发<!-- more -->\n<The rest of contents | 余下全文>\n### REST 简介\n\nREST即Representational State Transfer，由 Roy Fielding 在其博士论文 《 Architectural Styles and the Design of Network-based Software Architectures 》中提出，所以REST 并非标准，而是一种开发 Web 应用的架构风格。REST 基于 HTTP，URI（Uniform Resource Identifier）以及 XML 等现有的、广泛流行的协议和标准，促进了HTTP协议更好的使用。\n\n相较于基于 SOAP 和 WSDL 的 Web 服务，REST 模式提供了更为简洁的实现方案。目前，越来越多的 Web 服务采用了 REST 风格设计和实现，真实世界中比较著名的 REST 服务包括：Google AJAX 搜索 API、Amazon Simple Storage Service (Amazon S3)等。\n\n基于 REST 的 Web 服务遵循一些基本的设计原则：\n\n- 系统中每一个对象或资源都可以通过一个唯一的 URI 进行寻址，URI 的结构应该简单、可预测且易于理解\n- 以遵循 RFC-2616 定义的协议方式显式地使用 HTTP 方法，CRUD（Create, Retrieve, Update and Delete）操作与 HTTP 方法之间一一映射：\n\t- 若要在服务器上创建资源，应使用 POST 方法；\n\t- 若要检索某个资源，应该使用 GET 方法；\n\t- 若要更改资源状态或对其进行更新，应该使用 PUT 方法；\n\t- 若要删除某个资源，应该使用 DELETE 方法。\n- URI访问的每个资源都可以使用不同的形式进行表示（比如 XML、JSON），具体的表现形式取决于访问资源的客户端，客户端与服务提供者使用一种内容协商机制（请求头与 MIME 类型）来选择合适的数据格式，最小化彼此之间的数据耦合。\n\n### JAX-RS -- Java API for RESTful Web Services\n\nJava EE 6 引入了对 JSR-311 的支持。JSR-311（JAX-RS：Java API for RESTful Web Services）旨在定义一个统一规范，使得 Java 程序员可以使用一套固定的接口来开发 REST 应用，避免依赖于第三方框架。同时，JAX-RS 使用 POJO 编程模型和基于标注的配置，并集成了 JAXB，从而可以有效缩短 REST 应用的开发周期。\n\nJAX-RS 定义的 API 位于 javax.ws.rs 包中，其中一些主要的接口、标注和抽象类如图所示：\n![upload successful](/images/pasted-1.png)\nJAX-RS具体实现由第三方提供，例如 Sun Jersey、Apache CXF 以及 JBoss RESTEasy。\n\nWeb 资源作为一个 Resource 类来实现，对资源的请求由 Resource 方法来处理。Resource 类或 Resource 方法被打上了 Path 标注，Path 标注的值是一个相对的 URI 路径，用于对资源进行定位，路径中可以包含任意的正则表达式以匹配资源。和大多数 JAX-RS 标注一样，Path 标注是可继承的，子类或实现类可以继承超类或接口中的 Path 标注。\n\n\n#### 参数标注\n\nJAX-RS 中涉及 Resource 方法参数的标注包括：@PathParam、@MatrixParam、@QueryParam、@FormParam、@HeaderParam、@CookieParam、@DefaultValue 和 @Encoded。这其中最常用的是 @PathParam，它用于将 @Path 中的模板变量映射到方法参数，模板变量支持使用正则表达式，变量名与正则表达式之间用分号分隔，例如：@Path(\"/person/{id:\\\\d+}/\") 。\n\nJAX-RS 规定 Resource 方法中只允许有一个参数没有打上任何的参数标注，该参数称为实体参数，用于映射请求体。\n\n#### 参数与返回值类型\nResource 方法合法的参数类型包括：\n\n1. 原生类型\n2. 构造函数接收单个字符串参数或者包含接收单个字符串参数的静态方法 valueOf的任意类型\n3. List<T>，Set<T>，SortedSet<T>（T 为以上的 2 种类型）\n4. 用于映射请求体的实体参数\n\nResource 方法合法的返回值类型包括：\n\n1. void：状态码 204 和空响应体\n2. Response：Response 的 status 属性指定了状态码，entity 属性映射为响应体\n3. GenericEntity：GenericEntity 的 entity 属性映射为响应体，entity 属性为空则状态码为 204，非空则状态码为 200\n4. 其它类型：返回的对象实例映射为响应体，实例为空则状态码为 204，非空则状态码为 200\n\n对于错误处理，Resource 方法可以抛出非受控异常 WebApplicationException 或者返回包含了适当的错误码集合的 Response 对象。\n\n#### Context 标注\n通过 Context 标注，根 Resource 类的实例字段可以被注入如下类型的上下文资源：\n\n- Request、UriInfo、HttpHeaders、Providers、SecurityContext\n- HttpServletRequest、HttpServletResponse、ServletContext、ServletConfig\n\n### 内容协商与数据绑定\n\nWeb 资源可以有不同的表现形式，服务端与客户端之间需要一种称为内容协商（Content Negotiation）的机制：作为服务端，Resource 方法的 Produces 标注用于指定响应体的数据格式（MIME 类型），Consumes 标注用于指定请求体的数据格式；作为客户端，Accept 请求头用于选择响应体的数据格式，Content-Type 请求头用于标识请求体的数据格式。\n\nJAX-RS 依赖于 MessageBodyReader 和 MessageBodyWriter 的实现来自动完成返回值到响应体的序列化以及请求体到实体参数的反序列化工作，其中，XML 格式的请求／响应数据与 Java 对象的自动绑定依赖于 JAXB 的实现。\n\n用户可以使用 Provider 标注来注册使用自定义的 MessageBodyProvider。如例子所示，GsonProvider 类使用了 Google Gson 作为 JSON 格式的 MessageBodyProvider 的实现。\n\n``` java\n@Provider \n@Produces(\"application/json\") \n@Consumes(\"application/json\") \npublic class GsonProvider implements MessageBodyWriter<Object>, MessageBodyReader<Object> { \n \n   private final Gson gson; \n \n   public GsonProvider() { \n       gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setDateFormat( \n               \"yyyy-MM-dd\").create(); \n   } \n \n   public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return true; \n   } \n \n   public Object readFrom(Class<Object> type, Type genericType, Annotation[] annotations, MediaType mediaType,  MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException { \n       return gson.fromJson(new InputStreamReader(entityStream, \"UTF-8\"), type); \n   } \n \n   public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return true; \n   } \n \n   public long getSize(Object obj, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) { \n       return -1; \n   } \n \n   public void writeTo(Object obj, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)throws IOException, WebApplicationException { \n       entityStream.write(gson.toJson(obj, type).getBytes(\"UTF-8\")); \n   } \n}\n```\n### JAX-RS 与 JPA 的结合使用\n由于 JAX-RS 和 JPA 同样都使用了基于 POJO 和标注的编程模型，因而很易于结合在一起使用。示例应用中的 Web 资源同时也是持久化到数据库中的实体，同一个 POJO 类上既有 JAXB 的标注，也有 JPA 的标注 ( 或者还有 Gson 的标注 ) ，这使得应用中类的个数得以减少。如例子所示，Account 类可以在 JAX-RS 与 JPA 之间得到复用，它不但可以被 JAX-RS 绑定为请求体 / 响应体的 XML/JSON 数据，也可以被 JPA 持久化到关系型数据库中。\n\n``` java\n@Entity \n@Table(name = \"TABLE_ACCOUNT\") \n@XmlRootElement \npublic class Account { \n   @Id \n   @GeneratedValue(strategy = GenerationType.IDENTITY) \n   @Column(name = \"COL_ID\") \n   @Expose \n   private int id; \n \n   @ManyToOne \n   @JoinColumn(name = \"COL_PERSON\") \n   @Expose \n   private Person person; \n \n   @Column(name = \"COL_AMOUNT\") \n   @Expose \n   private BigDecimal amount; \n \n   @Column(name = \"COL_DATE\") \n   @Expose \n   private Date date; \n \n   @ManyToOne \n   @JoinColumn(name = \"COL_CATEGORY\") \n   @Expose \n   private Category category; \n \n   @Column(name = \"COL_COMMENT\") \n   @Expose \n   private String comment; \n   \n   ......\n```\n\n### 总结\nREST 作为一种轻量级的 Web 服务架构被越来越多的开发者所采用，JAX-RS 的发布则规范了 REST 应用开发的接口。\n\n引用链接：[使用 JAX-RS 简化 REST 应用开发](https://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/)","tags":["JAX-RS"],"categories":["REST"]}]